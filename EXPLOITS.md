# Exploits Documentation

This file contains documentation of the challenges we exploited as part of the CTF exercise. It includes the flags captured, the exploitation process, identified vulnerabilities, and suggested mitigations. **Note:** We did not attempt to capture flags from the challenge our group created.

---

## Challenge: epic_heisenberg

**Flags Captured:** 
- `CTF{You did it! that is our flag: https://www.youtube.com/watch?v=YEReRb8rDCw}`

**Exploitation Process:**

1. Registered a user (`admin@evil.com`)
2. Logged in and obtained a base64-encoded token containing the hashed `userId`
3. Decompiled the application JAR to reveal `VerifyToken.class`
4. Discovered that tokens are verified using:
   - `sha256(user_id + password)`
   - an in-memory access timestamp (`lastRequestedAccessToken`)
5. Reused the valid login token and changed only the `"role": "USER"` to `"ADMIN"`
6. Sent the updated token as a base64-encoded JSON string in the `accessToken` header
7. Gained access to `/schema`, which listed the `flag` table
8. Found the real flag in the migration script `V1_3__create_flag_table.sql`

**Vulnerabilities Found:**
- Custom insecure token system that accepts unsigned base64 JSON
- Token trust based solely on user-controlled fields (bad design)

**Mitigations:**
- Use real JWTs with strong HMAC or RSA signatures
- Never allow role elevation from client-side token data
- Store session state securely server-side with verified roles

---

## Challenge: fervent_lovelace  
**Flags Captured:**  
- `CTF-mazuz`

**Exploitation Process:**  
1. **Service Enumeration**  
   - The challenge runs a Docker container (`karlkl/sfs2`) exposing a web service on `http://localhost:5000/customers`.
   - The frontend is built with Angular and interacts with backend API endpoints like `/api/customers/page/0/10`.

2. **Initial Recon**  
   - The application exposes a customer list with a search field and a button to add new customers.
   - Browser console logs show API calls and confirm Angular usage (`getCustomersPage()`).

3. **XSS Discovery (Stored)**  
   - A customer entry contained an XSS payload using `<img onerror=eval(...)>` executing JavaScript in the admin's browser context.
   - The payload hints at a `Secrets` table in the database through obfuscated `console.log` statements.
   - Look at Customer http://localhost:5000/customers/23
   - The decoded hints says to download the database and get the Key from it

4. **Hidden in Image**
	- in the Secrets Table is an URL http://localhost:5000/assets/images/sfs.png
	- then use the image decode site https://incoherency.co.uk/image-steganography/#unhide
	- then the resulting string is CTF-0110110101100001011110100111010101111010
	- using AI to get the final string 'CTF-mazuz'

**Vulnerabilities Found:**  
- Stored Cross-Site Scripting (XSS):
- User input was rendered in the Angular frontend without proper sanitization, allowing for arbitrary JavaScript execution.
- Executed in the admin’s browser, leaking console-based hints

**Mitigations:**  
- Input Validation & Sanitization
- All user input should be sanitized both on the frontend and backend.
- HTML/JS injection must be strictly filtered or escaped.

---

## Challenge: happy_moore  
**Flags Captured:**  
- `CTF{flag1}`  
- `CTF{flag2}`  
- `CTF{flag3}`

**Exploitation Process:**  
- [Steps]

**Vulnerabilities Found:**  
- [Details]

**Mitigations:**  
- [Suggestions]

---

## Challenge: intelligent_hopper  
**Flags Captured:**  
- `CTF-1{flagA}`  
- `CTF-2{You have successfully accessed the file system!}`  
- `CTF-3{flagC}`  
- `CFT 4{sql_injection_mastered :)}`  
- `CTF-5{flagE}`  
- `CTF-6{ctf@catched.com}`  
- `CTF-7{flagG}`
- `CTF-8{free_order}`

**Exploitation Process:**  
- **CFT 4{sql_injection_mastered :)}**
	- Login on http://localhost:8080/login.php
	- Get Tables `'; SHOW TABLES; -- `
	- Email field: `admin@test.com'; SELECT * FROM secret_flag; -- "`
	- Password: `anything`
- **CFT 5{Try changing all user passwords at once}**
	- Accessed `/forgot-password.php` and reviewed source code  
	- Discovered the password reset is based only on email + contact number  
	- No token, no rate limiting, and passwords hashed with insecure `md5()`  
	- Dumped users table via phpMyAdmin (`root` / `root`)  
	- Used a valid email + contact combination from table:  
		- Email: `ctf@catched.com`  
		- Contact: `123456789`  
	- Successfully reset password to `hacked123`  
	- Confirmed reset via login  
	- System displayed: `Password Changed Successfully; CTF-5 Try changing all user passwords at once.`  
- **CTF-6{ctf@catched.com}**
	- from the sql injection before we know there is a user table
	- `admin@test.com'; SELECT * FROM users; -- `
	- there is an hidden user with an CTF inside

**Vulnerabilities Found:**  
- Insecure password reset mechanism:
  - No verification code or token required
  - No rate-limiting or lockout after failed attempts
  - Relies solely on `email + contact` (publicly enumerable)
  - Passwords stored as unsalted MD5 hashes

- Poor session handling in forgot-password logic:
  - Session flag (`$_SESSION['errmsg']`) set **after** `header()` redirect, may not persist

- User enumeration possible via SQL injection (see CTF-4)

**Mitigations:**  
- Implement secure password reset with time-bound, single-use tokens sent to verified email
- Store passwords using `bcrypt` or `argon2` with a per-user salt
- Move session state assignment **before** HTTP header redirect
- Rate-limit forgot-password attempts to prevent brute-forcing contact info
- Sanitize and parameterize all SQL queries to prevent injection

---

## Challenge: keen_hellman  

**Flags Captured:**  
- `CTF{ganbatte baka}`  
- `CTF{onii chan daisuki}`  
- `CTF{omae wa mou shindeiru OVER 9000}`  

**Exploitation Process:**  
1. Discovered the `/api/weapons` endpoint by inspecting network requests in the browser DevTools.  
2. Used classic SQL injection on `/api/weapons/{identifier}` to enumerate tables and extract the first flag `CTF{ganbatte baka}` from the `user_secrets` table.

```
http://localhost:8080/api/weapons/' UNION SELECT user_name, password, null, null, null FROM user_secrets --
```

3. Decompiled the application JAR and inspected the `TankController` class, discovering an encrypted flag string and a `key.txt` resource needed for XOR + Base64 decryption.  
4. Extracted the `key.txt` file from the application resources and used it to decrypt the encrypted string in `TankController`, revealing the third flag.  
5. Also found in the JAR the `AccessGuard` class implementing rate limiting on the `/api/validation` endpoint, which gates access to `/api/tanks`.  
6. Manually spammed the browser’s refresh button to flood the `/api/validation` endpoint, triggering the rate limit and causing it to return a special “rate limit exceeded” response.  
7. With the rate limit triggered, accessed the `/api/tanks` endpoint and received the final flag `CTF{omae wa mou shindeiru OVER 9000}` legitimately.  

**Vulnerabilities Found:**  
- SQL injection vulnerability in unparameterized database queries.  
- Exposed Spring Boot actuator endpoint leaking sensitive memory contents.  
- Flags stored in database, application memory, and encrypted resources with weak encryption.  
- Insufficient rate limiting and protection on validation endpoint enabling abuse.  

**Mitigations:**  
- Use parameterized queries to prevent SQL injection.  
- Disable or secure actuator endpoints in production.  
- Avoid storing sensitive data in plaintext within databases or application memory.  
- Use strong cryptography with secure key management.  
- Harden rate limiting and implement anti-abuse protections on API endpoints.  

---




