# Exploits Documentation

This file contains documentation of the challenges we exploited as part of the CTF exercise. It includes the flags captured, the exploitation process, identified vulnerabilities, and suggested mitigations. **Note:** We did not attempt to capture flags from the challenge our group created.

---

## Challenge: epic_heisenberg

**Flags Captured:** 
- `CTF{You did it! that is our flag: https://www.youtube.com/watch?v=YEReRb8rDCw}`

**Exploitation Process:**

1. Registered a user (`admin@evil.com`)
2. Logged in and obtained a base64-encoded token containing the hashed `userId`
3. Decompiled the application JAR to reveal `VerifyToken.class`
4. Discovered that tokens are verified using:
   - `sha256(user_id + password)`
   - an in-memory access timestamp (`lastRequestedAccessToken`)
5. Reused the valid login token and changed only the `"role": "USER"` to `"ADMIN"`
6. Sent the updated token as a base64-encoded JSON string in the `accessToken` header
7. Gained access to `/schema`, which listed the `flag` table
8. Found the real flag in the migration script `V1_3__create_flag_table.sql`

**Vulnerabilities Found:**
- Custom insecure token system that accepts unsigned base64 JSON
- Token trust based solely on user-controlled fields (bad design)

**Mitigations:**
- Use real JWTs with strong HMAC or RSA signatures
- Never allow role elevation from client-side token data
- Store session state securely server-side with verified roles

---

## Challenge: fervent_lovelace  
**Flags Captured:**  
- `CTF-mazuz`

**Exploitation Process:**  
1. **Service Enumeration**  
   - The challenge runs a Docker container (`karlkl/sfs2`) exposing a web service on `http://localhost:5000/customers`.
   - The frontend is built with Angular and interacts with backend API endpoints like `/api/customers/page/0/10`.

2. **Initial Recon**  
   - The application exposes a customer list with a search field and a button to add new customers.
   - Browser console logs show API calls and confirm Angular usage (`getCustomersPage()`).

3. **XSS Discovery (Stored)**  
   - A customer entry contained an XSS payload using `<img onerror=eval(...)>` executing JavaScript in the admin's browser context.
   - The payload hints at a `Secrets` table in the database through obfuscated `console.log` statements.
   - Look at Customer http://localhost:5000/customers/23
   - The decoded hints says to download the database and get the Key from it

4. **Hidden in Image**
	- in the Secrets Table is an URL http://localhost:5000/assets/images/sfs.png
	- then use the image decode site https://incoherency.co.uk/image-steganography/#unhide
	- then the resulting string is CTF-0110110101100001011110100111010101111010
	- using AI to get the final string 'CTF-mazuz'

**Vulnerabilities Found:**  
- Stored Cross-Site Scripting (XSS):
- User input was rendered in the Angular frontend without proper sanitization, allowing for arbitrary JavaScript execution.
- Executed in the adminâ€™s browser, leaking console-based hints

**Mitigations:**  
- Input Validation & Sanitization
- All user input should be sanitized both on the frontend and backend.
- HTML/JS injection must be strictly filtered or escaped.

---

## Challenge: happy_moore  
**Flags Captured:**  
- `CTF{flag1}`  
- `CTF{flag2}`  
- `CTF{flag3}`

**Exploitation Process:**  
- [Steps]

**Vulnerabilities Found:**  
- [Details]

**Mitigations:**  
- [Suggestions]

---

## Challenge: intelligent_hopper  
**Flags Captured:**  
- `CTF-1{flagA}`  
- `CTF-2{flagB}`  
- `CTF-3{flagC}`  
- `CTF-4{flagD}`  
- `CTF-5{flagE}`  
- `CTF-6{flagF}`  
- `CTF-7{flagG}`  
- `CFT 4{flagH}`

**Exploitation Process:**  
- [Steps]

**Vulnerabilities Found:**  
- [Details]

**Mitigations:**  
- [Suggestions]

---

## Challenge: keen_hellman  

**Flags Captured:**  
- `CTF{ganbatte baka}`  
- `CTF{onii chan daisuki}`  
- `CTF{omae wa mou shindeiru OVER 9000}`  

**Exploitation Process:**  
1. Inspected the web UI and found a challenge requiring three flags to unlock the final content.  
2. Decompiled the application JAR to analyze the backend code (`SolutionController`, `WeaponService`, `TankController`).  
3. Discovered the first flag stored in the SQLite database `user_secrets` table under the `admin` user.  
4. Found the second flag hardcoded as a constant string inside the `WeaponService` class.  
5. Extracted the key file `key.txt` from the resources and decrypted the encrypted flag string in the `TankController` using XOR + Base64 decryption, revealing the third flag.  

**Vulnerabilities Found:**  
- Sensitive flags stored in various places: database, code constants, and encrypted resources.  
- Simple XOR encryption with a static key easily extracted from application resources.  
- Lack of proper rate limiting on the `/api/tanks` endpoint initially mitigated by a rate limiter but still exploitable via resource extraction.  

**Mitigations:**  
- Avoid storing sensitive flags or secrets in application code or database in plaintext.  
- Use strong encryption methods and keep keys out of publicly accessible resources.  
- Implement strict rate limiting and request validation on sensitive endpoints.  
- Obfuscate or remove flags and test artifacts from production builds.  

---



