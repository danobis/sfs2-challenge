# Exploits Documentation

This file contains documentation of the challenges we exploited as part of the CTF exercise. It includes the flags captured, the exploitation process, identified vulnerabilities, and suggested mitigations. **Note:** We did not attempt to capture flags from the challenge our group created.

---

## Challenge: epic_heisenberg

**Flags Captured:** 
- `CTF{You did it! that is our flag: https://www.youtube.com/watch?v=YEReRb8rDCw}`

**Exploitation Process:**

1. Registered a user (`admin@evil.com`)
2. Logged in and obtained a base64-encoded token containing the hashed `userId`
3. Decompiled the application JAR to reveal `VerifyToken.class`
4. Discovered that tokens are verified using:
   - `sha256(user_id + password)`
   - an in-memory access timestamp (`lastRequestedAccessToken`)
5. Reused the valid login token and changed only the `"role": "USER"` to `"ADMIN"`
6. Sent the updated token as a base64-encoded JSON string in the `accessToken` header
7. Gained access to `/schema`, which listed the `flag` table
8. Found the real flag in the migration script `V1_3__create_flag_table.sql`

**Vulnerabilities Found:**
- Custom insecure token system that accepts unsigned base64 JSON
- Token trust based solely on user-controlled fields (bad design)

**Mitigations:**
- Use real JWTs with strong HMAC or RSA signatures
- Never allow role elevation from client-side token data
- Store session state securely server-side with verified roles

---

## Challenge: fervent_lovelace  
**Flags Captured:**  
- `CTF-mazuz`

**Exploitation Process:**  
1. **Service Enumeration**  
   - The challenge runs a Docker container (`karlkl/sfs2`) exposing a web service on `http://localhost:5000/customers`.
   - The frontend is built with Angular and interacts with backend API endpoints like `/api/customers/page/0/10`.

2. **Initial Recon**  
   - The application exposes a customer list with a search field and a button to add new customers.
   - Browser console logs show API calls and confirm Angular usage (`getCustomersPage()`).

3. **XSS Discovery (Stored)**  
   - A customer entry contained an XSS payload using `<img onerror=eval(...)>` executing JavaScript in the admin's browser context.
   - The payload hints at a `Secrets` table in the database through obfuscated `console.log` statements.
   - Look at Customer http://localhost:5000/customers/23
   - The decoded hints says to download the database and get the Key from it

4. **Hidden in Image**
	- in the Secrets Table is an URL http://localhost:5000/assets/images/sfs.png
	- then use the image decode site https://incoherency.co.uk/image-steganography/#unhide
	- then the resulting string is CTF-0110110101100001011110100111010101111010
	- using AI to get the final string 'CTF-mazuz'

**Vulnerabilities Found:**  
- Stored Cross-Site Scripting (XSS):
- User input was rendered in the Angular frontend without proper sanitization, allowing for arbitrary JavaScript execution.
- Executed in the admin’s browser, leaking console-based hints

**Mitigations:**  
- Input Validation & Sanitization
- All user input should be sanitized both on the frontend and backend.
- HTML/JS injection must be strictly filtered or escaped.

---

## Challenge: happy_moore  
**Flags Captured:**  
- `CTF{11791b95-2d10-4fb4-9c7b-f7d7da265576}`  
- `CTF{4e89636b-7fd7-4f6c-b915-92876d660227}`  
- `CTF{667b8d16-09a8-4cb0-b122-2623d23cb6a0}`

**Exploitation Process:**  
1. **File Retrieval via SQL Injection**  
   - Found a `/GetFileUrl` endpoint that accepted both `filename` and `password` parameters.  
   - Injected a test payload into `filename`, e.g. `test'`, and received SQL errors — indicating injectable context.  
   - Used standard SQLi enumeration tactics (`UNION ALL SELECT ...`) to infer column count and schema.  
   - Queried the `sqlite_schema` and dumped `secret` table entries with:  
     `' UNION ALL SELECT password, filename, 3, 4 FROM secret; --`  
   - Passwords were obfuscated; determined the decryption method was Caesar cipher, and the key was stored in the same table.  
   - Deciphered the correct password and downloaded a binary named `secretfile`.

2. **Flag from Format String Vulnerability**  
   - Executed the binary and selected the first option in the menu, which prompted for input passed to `echo(buf)` internally.  
   - Used a simple format string exploit (`%1$s`) to leak the first variadic argument, which revealed the flag in memory.

3. **Flag from Logic Flaw in Authorization Check**  
   - Chose the second exploit option in the menu.  
   - Passed a negative array index (`-4`), which overwritten a permission variable in memory.  
   - Subsequent input enabled access to a restricted branch of the code that printed the next flag.

4. **Hidden Menu Path / Buffer Check**  
   - Disassembled the binary and inspected a `switch` statement in `utils.c`, noticing an unused case: `case 1000`.  
   - Entered `1000` as menu input to reach the hidden logic.  
   - Then entered a specifically crafted string of 29 characters, with the final character being ASCII `73` (`I`), triggering a secret-flag condition.

**Vulnerabilities Found:**  
- SQL injection on filename input, allowing full DB readout.  
- Caesar-encrypted secrets stored insecurely.  
- Format string vulnerability leaking memory.  
- Unsafe buffer logic with negative indexing enabling privilege escalation.  
- Hidden logic triggered through magic values and unchecked input length.

**Mitigations:**  
- Parameterize all SQL queries and validate input.  
- Avoid storing secrets in the DB in reversible formats.  
- Use `snprintf` and avoid unfiltered `printf(buf)` patterns.  
- Sanitize and bounds-check all array access, especially user-controlled indexing.  
- Remove debug or unused logic from compiled releases.

---

## Challenge: intelligent_hopper  
**Flags Captured:**  
- `CTF-1{Try to show this div in the page: CTF-1}`  
- `CTF-2{You have successfully accessed the file system!}`  
- `CFT 4{sql_injection_mastered :)}`  
- `CTF-5{Try changing all user passwords at once}`  
- `CTF-6{ctf@catched.com}`  
- `CTF-8{free_order}`

**Exploitation Process:**  
1. **Stored XSS for DOM Flag (CTF-1)**  
   - On the product review page, injected a `<script>` into the review field.  
   - This script accessed a hidden `<div id="ctf-1">` and toggled its visibility via `style.display`.  
   - We were only aware of this flag after examining the PHP application source.

2. **Web Shell Upload via File Upload (CTF-2)**  
   - Review image upload accepted `.php` files as long as their name resembled an image.  
   - Uploaded a basic PHP shell to `/uploads/reviews/`.
   - Used these commands to reveal the flag:

```
http://localhost:8080/uploads/reviews/image.php?cmd=ls+-la+/var/www/html
http://localhost:8080/uploads/reviews/image.php?cmd=cat /var/www/html/ctf2.txt
```

3. **SQL Injection via Login Form (CTF-4, CTF-6)**  
   - Login form vulnerable to SQL injection.  
   - Used `' AND 1=0; SHOW TABLES; --` to enumerate schema.  
   - Queried `secret_flag` directly to extract a flag.  
   - Also used `' OR 1=1 --` to dump users and find a flag embedded in a user email (CTF-6).
     
   - **Alternative approach**:
   	- Login on http://localhost:8080/login.php
	- Get Tables `'; SHOW TABLES; -- `
	- Email field: `admin@test.com'; SELECT * FROM secret_flag; -- "`Add commentMore actions
	- Password: `anything`

5. **Password Reset Exploit (CTF-5)**
   - Accessed `/forgot-password.php` and reviewed source code  
	- Discovered the password reset is based only on email + contact number  
	- No token, no rate limiting, and passwords hashed with insecure `md5()` 
   - No verification or email required.  
   - Used `' OR 1=1 -- '` in email field to reveal the flag.
     
   - **Alternative approach**:
	- Dumped users table via phpMyAdmin (`root` / `root`)  
	- Used a valid email + contact combination from table:  
		- Email: `ctf@catched.com`  
		- Contact: `123456789`  
	- Successfully reset password to `hacked123`  
	- Confirmed reset via login  

6. **Business Logic Flaw for Free Orders (CTF-8)**  
   - Admin credentials were leaked in source comments of the admin login page.  
   - Logged in as admin and generated a 100% discount code.  
   - Logged in as a user and placed an order using the discount.  
   - Flag appeared in `order-history.php` for free orders.

**Vulnerabilities Found:**  
- Stored XSS executed in admin context.  
- File upload unrestricted — allowed `.php` web shells.  
- SQL injection in login and password reset flows.
- Passwords stored as unsalted MD5 hashes 
- No verification/tokenization in password reset.  
- Broken access control on admin and internal APIs.  
- Coupon logic lacked checks — exploitable for free purchases.

**Mitigations:**  
- Sanitize and encode all user input displayed in the DOM.  
- Validate file type server-side and restrict to images only.  
- Parameterize SQL queries and disable multi-statement support.  
- Add email verification and single-use tokens for password reset.  
- Enforce RBAC and do not expose admin tools in production.  
- Validate coupon codes server-side and check user permissions.

---

## Challenge: keen_hellman  

**Flags Captured:**  
- `CTF{ganbatte baka}`  
- `CTF{onii chan daisuki}`  
- `CTF{omae wa mou shindeiru OVER 9000}`  

**Exploitation Process:**  
1. Discovered the `/api/weapons` endpoint by inspecting network requests in the browser DevTools.  
2. Used classic SQL injection on `/api/weapons/{identifier}` to enumerate tables and extract the first flag `CTF{ganbatte baka}` from the `user_secrets` table.

```
http://localhost:8080/api/weapons/' UNION SELECT user_name, password, null, null, null FROM user_secrets --
```

3. Decompiled the application JAR and inspected the `TankController` class, discovering an encrypted flag string and a `key.txt` resource needed for XOR + Base64 decryption.  
4. Extracted the `key.txt` file from the application resources and used it to decrypt the encrypted string in `TankController`, revealing the third flag.  
5. Also found in the JAR the `AccessGuard` class implementing rate limiting on the `/api/validation` endpoint, which gates access to `/api/tanks`.  
6. Manually spammed the browser’s refresh button to flood the `/api/validation` endpoint, triggering the rate limit and causing it to return a special “rate limit exceeded” response.  
7. With the rate limit triggered, accessed the `/api/tanks` endpoint and received the final flag `CTF{omae wa mou shindeiru OVER 9000}` legitimately.  

**Vulnerabilities Found:**  
- SQL injection vulnerability in unparameterized database queries.  
- Exposed Spring Boot actuator endpoint leaking sensitive memory contents.  
- Flags stored in database, application memory, and encrypted resources with weak encryption.  
- Insufficient rate limiting and protection on validation endpoint enabling abuse.  

**Mitigations:**  
- Use parameterized queries to prevent SQL injection.  
- Disable or secure actuator endpoints in production.  
- Avoid storing sensitive data in plaintext within databases or application memory.  
- Use strong cryptography with secure key management.  
- Harden rate limiting and implement anti-abuse protections on API endpoints.  

---




